# package samples.useaclass

# A class for Complex numbers (in it's own file Complex.java)
# In file we use access specifiers (public , private) to achieve
# information hiding.
# 
# To test the class run TextComplex.
class Complex:
    # ---- Constructors --------------------

    # This is a constructor, called when using Complex(...). Used to initialize the object
    def __init__(self, *args):
        if len(args) == 2:
            self.__re = float(args[0])
            self.__img = float(args[1])
        elif len(args) == 1 and (type(other := args[0])) == type(self):
            self.__re = other.get_real_part()
            self.__img = other.get_img_part()
        elif len(args) == 1:
            self.__re = float(args[0])
            self.__img = 0

    # --- Instance methods ---------------
    # Always return a new Complex (because we normally assume operands won't change)
    def add(self, other):
        return Complex(self.get_real_part() + other.get_real_part(),
                       self.get_img_part() + other.get_img_part())

    # Overriding built-in __add__ lets us use the + operator
    def __add__(self, other):
        return self.add(other)

    def sub(self, other):
        return Complex(self.get_real_part() - other.get_real_part(),
                       self.get_img_part() - other.get_img_part())

    # Overriding built-in __sub__ lets us use the - operator
    def __sub__(self, other):
        return self.sub(other)

    # Must use methods to access private variables (getters)
    def get_real_part(self):    # Possible access parts if complex
        return self.__re

    def get_img_part(self):
        return self.__img

    # Below are 3 method that your classes probably should implement
    #
    # The methods are in fact present in any class, implicit inherited from the class object
    # (standard python class). But, ...the inherited methods often doesn't behave as we wish.
    # Usually we need to create own versions of the methods to replace the existing (overriding)

    # NOTE: All of them can be Generated by PyCharm, right click > Generate ...

    # This is one way to implement equality between objects (by value)
    # If not adding this method you'll get equality by reference (i.e. identity)
    # If not adding this method, objects in Collections will not be found!
    def __eq__(self, o: object) -> bool:
        if self is o:
            return True  # Same object identity
        if not isinstance(o, Complex):
            return False    # Not even same type
        return self.get_real_part() == o.get_real_part() and \
            self.get_img_part() == o.get_img_part()

    # Overriding __hash__ is necessary if we want to use values of Complex
    # as keys in a dictionary. If we don't override __eq__, we get an automatic
    # inherited version of __hash__ based on object identity. But when we override
    # __eq__, we must also override __hash__, in such a way that if
    # c1 == c2 then hash(c1) == hash(c2). This is easy, by hashing a tuple of the
    # relevant attributes.
    def __hash__(self) -> int:
        return hash((self.__re, self.__img))

    # Create a human readable string out of an object (or parts of object)
    # This method is automatically called when using print()
    def __str__(self) -> str:
        re = self.get_real_part()
        img = self.get_img_part()
        if re == 0 and img == 0:
            return "0"
        elif re == 0:
            return f"{img}i"
        elif img == 0:
            return str(re)
        elif img > 0:
            return f"{re} + {img}i"
        else:
            return f"{re} - {-1 * img}i"

    # Create a unique representation out of an object
    # This method is used when showing the object in the console or debug screen
    def __repr__(self) -> str:
        return f"Complex({self.get_real_part()}, {self.get_img_part()})"

